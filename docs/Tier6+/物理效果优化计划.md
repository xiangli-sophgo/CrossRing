# Tier6+model 3D物理效果与视觉增强优化计划

## 一、项目现状分析

### 当前技术栈
- **3D视图**: Three.js + react-three-fiber + @react-three/drei
- **拓扑图**: SVG + 自定义布局算法（6种）
- **动画**: react-spring + CSS transitions
- **后处理**: @react-three/postprocessing (Bloom)

### 当前不足
1. **3D视图缺乏物理引擎**：没有碰撞检测、重力、刚体模拟
2. **拓扑图无物理模拟**：使用确定性布局算法，缺乏力导向图的动态效果
3. **数字孪生感不足**：没有实时数据流可视化、热力学效果、动态粒子

---

## 二、3D视图物理效果增强

### 2.1 引入物理引擎

**推荐方案**: `@react-three/rapier`（基于 Rapier.rs，性能优秀）

**文件修改**:
- `frontend/src/components/Scene3D/Scene3D.tsx`
- 新建 `frontend/src/components/Scene3D/physics/`

**实现内容**:

```typescript
// 1. 添加物理世界容器
import { Physics, RigidBody, CuboidCollider } from '@react-three/rapier'

<Physics gravity={[0, -9.81, 0]} debug={false}>
  {/* 所有需要物理的对象 */}
</Physics>

// 2. 机柜碰撞体
<RigidBody type="fixed" colliders="cuboid">
  <AnimatedRack {...props} />
</RigidBody>

// 3. 可交互的板卡（可拖拽、碰撞）
<RigidBody type="dynamic" mass={0.5}>
  <BoardModel {...props} />
</RigidBody>
```

**效果**:
- 板卡可物理拖拽并自动落入机柜槽位
- 碰撞反馈（悬停时微微震动）
- 机柜门开关动画（铰链约束）

---

### 2.2 数字孪生视觉效果

#### A. 实时数据流可视化

**文件新建**: `frontend/src/components/Scene3D/effects/DataFlow.tsx`

**实现**:
```typescript
// 粒子系统表示数据流
import { useFrame } from '@react-three/fiber'
import { Points, PointMaterial } from '@react-three/drei'

const DataFlowParticles = ({ sourcePos, targetPos, color, speed }) => {
  // 沿着连接线移动的粒子
  // 粒子密度根据流量大小调整
}
```

**效果**:
- 芯片间通信显示流动粒子
- 粒子颜色/密度反映流量大小
- 路径跟随拓扑连接

#### B. 热力学可视化

**文件新建**: `frontend/src/components/Scene3D/effects/HeatMap3D.tsx`

**实现**:
```typescript
// 芯片热量着色
const ChipHeatShader = {
  uniforms: {
    temperature: { value: 0.5 },  // 0-1 归一化温度
    time: { value: 0 }
  },
  // 渐变色：蓝(冷) → 绿 → 黄 → 红(热)
}

// 热气上升粒子效果
const HeatRisingParticles = ({ chipPosition, temperature }) => {
  // 向上飘散的热气粒子
}
```

**效果**:
- 芯片表面根据负载/温度动态着色
- 高负载时有热气上升粒子效果
- 配合流量分析结果实时更新

#### C. 环境增强

**文件修改**: `frontend/src/components/Scene3D/Scene3D.tsx`

**实现**:
```typescript
import { Environment, ContactShadows, Caustics } from '@react-three/drei'

// 1. 环境反射
<Environment preset="warehouse" background={false} />

// 2. 接触阴影（更柔和）
<ContactShadows
  position={[0, -0.01, 0]}
  blur={2}
  opacity={0.5}
/>

// 3. 焦散效果（金属反光）
<Caustics color="#88ccff" intensity={0.03}>
  {/* 金属部件 */}
</Caustics>
```

---

### 2.3 交互增强

#### A. 物理拖拽

**实现**:
```typescript
import { useDrag } from '@use-gesture/react'
import { useRapier, RigidBody } from '@react-three/rapier'

const DraggableBoard = () => {
  const bind = useDrag(({ delta }) => {
    // 施加力而非直接设置位置
    rigidBodyRef.current.applyImpulse(...)
  })

  return (
    <RigidBody ref={rigidBodyRef}>
      <mesh {...bind()}>
        <BoardModel />
      </mesh>
    </RigidBody>
  )
}
```

#### B. 弹簧连接

**实现**:
```typescript
import { useSpringValue } from '@react-spring/three'

// 节点间弹簧连接可视化
const SpringConnection = ({ nodeA, nodeB, stiffness }) => {
  // 弹簧线段，随距离变化粗细和颜色
}
```

---

## 三、拓扑图物理效果增强

### 3.1 力导向布局引擎

**推荐方案**: `d3-force` 或 `@interactjs/force`

**文件修改**:
- `frontend/src/components/TopologyGraph/layouts.ts`
- `frontend/src/components/TopologyGraph/TopologyGraph.tsx`

**新增布局算法**:
```typescript
// layouts.ts 新增
import * as d3 from 'd3-force'

export function forceDirectedLayout(
  nodes: Node[],
  edges: Edge[],
  options: ForceOptions
): { nodes: Node[], simulation: d3.Simulation } {
  const simulation = d3.forceSimulation(nodes)
    .force('charge', d3.forceManyBody().strength(-300))  // 节点间斥力
    .force('link', d3.forceLink(edges).distance(100))    // 边的弹簧力
    .force('center', d3.forceCenter(400, 300))           // 中心力
    .force('collision', d3.forceCollide(30))             // 碰撞检测

  return { nodes, simulation }
}
```

**效果**:
- 节点自动排斥，避免重叠
- 连接线像弹簧一样保持合适距离
- 拖拽时其他节点平滑让开

---

### 3.2 弹簧动画系统

**文件新建**: `frontend/src/components/TopologyGraph/physics/SpringSystem.ts`

**实现**:
```typescript
interface SpringNode {
  x: number; y: number;
  vx: number; vy: number;  // 速度
  fx: number; fy: number;  // 受力
  mass: number;
  damping: number;  // 阻尼
}

class SpringPhysicsEngine {
  private nodes: Map<string, SpringNode>
  private springs: Array<{ a: string, b: string, stiffness: number, restLength: number }>

  step(dt: number) {
    // 1. 计算弹簧力
    // 2. 计算节点间斥力
    // 3. 积分位置
    // 4. 应用阻尼
  }
}
```

**效果**:
- 拖拽节点时连接线有张力感
- 释放后节点有惯性滑动并回弹
- 整体布局有"呼吸感"

---

### 3.3 多层级视图物理增强

**文件修改**: `frontend/src/components/TopologyGraph/TopologyGraph.tsx`

**当前问题**: 多层级视图使用 CSS Skew 变换，缺乏深度感

**增强方案**:

#### A. 层级弹簧悬浮
```typescript
// 每层容器有独立的弹簧参数
const layerSpring = useSpring({
  y: hoveredLayer === zLayer ? -30 : 0,
  rotateX: hoveredLayer === zLayer ? 5 : 0,  // 微微倾斜
  config: { mass: 1, tension: 180, friction: 20 }
})
```

#### B. 层间连接弹性线
```typescript
// 跨层连接线有弹性效果
const InterLevelConnection = ({ sourceLayer, targetLayer }) => {
  // 曲线张力随距离变化
  // 悬停时线条"紧绷"
}
```

#### C. 容器展开物理动画
```typescript
// 容器展开时内部节点"散开"
const expandAnimation = () => {
  // 1. 容器放大
  // 2. 内部节点从中心向外弹射
  // 3. 弹簧力让节点稳定在最终位置
}
```

---

## 四、其他优化建议

### 4.1 性能优化

| 优化项 | 当前状态 | 建议方案 |
|-------|---------|---------|
| 大规模节点渲染 | SVG 直接渲染 | 虚拟化 + Canvas |
| 3D InstancedMesh | 仅引脚使用 | 扩展到Switch端口 |
| 物理模拟线程 | 无 | Web Worker |
| 动画帧率 | 无限制 | requestAnimationFrame 节流 |

### 4.2 视觉效果增强

| 效果 | 实现方案 | 文件位置 |
|-----|---------|---------|
| 景深效果 | DepthOfField 后处理 | Scene3D.tsx |
| 体积光 | VolumetricLight shader | effects/VolumetricLight.tsx |
| 抗锯齿增强 | SMAA 后处理 | Scene3D.tsx |
| 地面反射 | Reflector plane | Scene3D.tsx |
| LED呼吸灯 | emissive 动画 | models.tsx |

### 4.3 用户体验优化

1. **性能监控面板**: 显示 FPS、Draw Calls、内存使用
2. **物理调试模式**: 显示碰撞体、力向量
3. **截图/录制功能**: 导出 PNG/GIF/WebM
4. **VR/AR 支持**: WebXR 接入（长期）

### 4.4 代码架构优化

1. **状态管理升级**: 使用 Zustand 替代 useState 散落
2. **物理引擎抽象**: 创建 `PhysicsProvider` 统一管理
3. **效果系统模块化**: 独立的 `effects/` 目录管理所有视觉效果

---

## 五、实施优先级

### 第一阶段：拓扑图物理效果（已完成 ✅）
1. ✅ 力导向布局算法（d3-force）
2. ✅ 弹簧动画系统（节点拖拽惯性、连接线张力）
3. ✅ 多层级物理动画（层级悬浮、展开弹射）

### 第二阶段：3D视图物理效果（待实现）
4. 引入 @react-three/rapier 物理引擎
5. 机柜/板卡碰撞体设置
6. 物理拖拽交互

### 第三阶段：数字孪生可视化效果（待实现）
7. 数据流粒子系统
8. 芯片热力可视化
9. 环境光照增强（反射、柔和阴影）
10. LED呼吸灯效果

### 第四阶段：高级效果（可选）
11. 体积光/景深等高级后处理
12. 性能优化（虚拟化、Worker）
13. VR/AR 支持

---

## 六、关键文件清单

### 已修改的文件（第一阶段）
- `frontend/src/components/TopologyGraph/layouts.ts` - 添加力导向布局算法和 ForceLayoutManager
- `frontend/src/components/TopologyGraph/TopologyGraph.tsx` - 集成力导向布局和动态模拟
- `frontend/src/components/TopologyGraph/physics/useForceLayout.ts` - 力导向布局 Hook
- `frontend/src/types.ts` - 添加 'force' 布局类型
- `frontend/src/index.css` - 添加物理动画 CSS

### 需新建的文件（后续阶段）
```
frontend/src/components/Scene3D/
├── physics/
│   ├── PhysicsProvider.tsx      # 物理引擎容器
│   ├── RigidBodyWrapper.tsx     # 刚体包装组件
│   └── constraints.ts            # 约束定义（铰链、弹簧）
├── effects/
│   ├── DataFlowParticles.tsx    # 数据流粒子
│   ├── HeatMap3D.tsx            # 3D热力图
│   ├── HeatRisingEffect.tsx     # 热气上升效果
│   └── VolumetricLight.tsx      # 体积光
└── shaders/
    ├── heatGradient.glsl        # 热力渐变着色器
    └── dataFlow.glsl            # 数据流着色器
```

### 已安装的依赖
```bash
npm install d3-force @types/d3-force
```

### 待安装的依赖（第二阶段）
```bash
npm install @react-three/rapier @use-gesture/react
```

---

## 七、第一阶段实现总结

### 已完成功能

**1. 力导向布局算法**
- 新增 `forceDirectedLayout()` 函数
- 使用 d3-force 实现节点斥力、连接弹簧力、碰撞检测
- 支持边界约束防止节点飞出视图

**2. 动态力导向模拟**
- 新增 `ForceLayoutManager` 类管理物理模拟
- 实时更新节点位置（每帧 tick）
- 节点拖拽时其他节点自动让开
- 释放后节点有惯性滑动并回弹

**3. 多层级视图物理动画增强**
- 使用弹簧曲线 `cubic-bezier(0.34, 1.56, 0.64, 1)` 实现过冲效果
- 悬浮时层级微缩放（0.98）增加深度感
- 倾斜(skew)动画也应用弹簧效果

**4. 节点交互效果**
- 力导向模式：直接拖拽（无需 Shift 键）
- 拖拽时节点放大 1.08 倍并增强阴影
- grab/grabbing 光标反馈
- 状态指示器显示"模拟中/已稳定"

### 使用方式
在拓扑图工具栏选择"力导向"布局，即可体验：
- 节点自动排斥避免重叠
- 直接拖拽节点，其他节点会让开
- 释放后节点平滑回弹
